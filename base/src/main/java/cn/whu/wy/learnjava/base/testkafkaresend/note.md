# Kafka RPO=0 方案

## 场景

主机房kafka的两个生产者A、B均从DB读取业务指令（有各自的流水号），处理后发往同一个分区P。下游C消费此分区，并将结果发给外部。

主机房挂了之后，备机房要断点续作，对外发消息不能重发、漏发。

如果kafka支持RPO=0，那么备机房的kafka分区与主机房完全同步。备机房通过回溯此分区（或者主机房通过事务记录了发送点），能找出主机房在P分区上的发送位置。然后备机房的生产者A、B便能接着往P分区发消息。C继续处理。

但是，Kafka不支持跨机房RPO=0。自己实现：主机房事务提交Kafka和DB，DB记录kafka的点。

> 问题：主机房先提交kafka事务，后提交DB事务。备机房只能同步得到DB事务里面的断点，kafka事务的断点呢？丢了。那备机房从落后的DB断点开始处理，kafka怎么去重？kafka不需要去重，备机房是一个空的kafka，需要从头消费，以灌满水管。DB的断点决定了对外发送的位置。

问题：分区里面的消息顺序，与主机房不一致。消费此分区的下游要做到不对外重发。

## 思路一：备机房只恢复单一序

严格来说单一序并不需要恢复，天然就是。

- 由于每个生产者都是顺序发送的，P分区的消息虽然混合无序，但是对任一生产者来说是有序的
- 既然有序，如果备机房知道主机房的每个生产者发送了多少个，那么备机房就能恢复出单一有序。例如：A发送3个，B发了2个，假设主机房的顺序是A1-A2-B1-B2-A3，备机房可能的顺序为B1-B2-A1-A2-A3。如果备机房按这个顺序处理，会有问题吗？
  - 如果有，这个思路GG
  - 如果没有，也就是说这5个消息的结果已经发出去了，C不会再处理这5个消息，这5个消息直接跳过。如果不处理，那顺序就不要紧。备机房知道主机房发了多少个，只是为了过滤，从第6个消息开始处理。那么，这个第6个消息以及后面的所有消息，与主机房的顺序肯定不一样，有关系吗？没关系，因为主机房还没处理这些消息，这些消息的顺序没有对外产生影响。
  - 所以这5个消息能直接跳过吗？如果跳过了，主机房这5个消息产生的状态如何恢复？从DB恢复吗？

## 思路二：备机房恢复全局序

假设主机房的顺序A1-A2-B1-B2-A3，该顺序通过DB同步到备机房。

### 方案1，从生产者入手

备机房的A、B两个在往P写消息时，如何协调，使得写出的顺序与主机房一致。

- 可以预见效率很低，本来是批量写，为了保证顺序，只能几个几个的写
- 

### 方案2，从消费者入口

C在消费P的时候，一边消费一边排序，使得消费顺序与主机房一致。

需要注意的是，即使C发出去的消息是纠正后的正确顺序，如果下游的分区除了C还有其他写入方，那么顺序就又乱了。因此，C的下游仍然要做纠正顺序的事情。



#### 无限缓存方案 Main1.java

- 不匹配的消息全部放入缓存，后续命中缓存后移除。
- 优势：只需消费一次
- 劣势：极端场景下，缓存大小接近于消息量，内存吃不消

以下是测试不同数据量下，缓存的最大容量：

20万

```
首次命中:145033
缓存命中:54967
合计命中:200000
缓存最大容量:4953, 缓存比例:2%, 耗时:1s

首次命中:128644
缓存命中:71356
合计命中:200000
缓存最大容量:24625, 缓存比例:12%, 耗时:1s
```

100万

```
首次命中:508155
缓存命中:491845
合计命中:1000000
缓存最大容量:297375, 缓存比例:29%, 耗时:5s

首次命中:556697
缓存命中:443303
合计命中:1000000
缓存最大容量:129634, 缓存比例:12%, 耗时:7s
```

1000万

```
首次命中:5009732
缓存命中:4990268
合计命中:10000000
缓存最大容量:2186414, 缓存比例:21%, 耗时:75s

首次命中:5016339
缓存命中:4983661
合计命中:10000000
缓存最大容量:3166545, 缓存比例:31%, 耗时:68s

缓存最大容量:4591199, 缓存比例:45%, 耗时:41s
缓存最大容量:407639, 缓存比例:4%, 耗时:80s
```

#### 有限缓存方案 Main2.java

需要多次poll。 以下测试缓存大小与poll次数的关系，力求找到平衡点。

bitchSize=1万，两方写，平均情况，2万的缓存能覆盖全。

跑不下去，提前终止。

| 数据量   | 缓存大小 | poll次数   | 处理时间(s) |
|-------|------|----------|---------|
| 100万  | 1万   | 631200 + | 90+     |
| 100万  | 2万   | +++      | +++     |
| 100万  | 5万   | +++      | +++     |
| 100万  | 10万  | +++      | +++     |
| 1000万 | 1万   |          |         |
| 1000万 | 2万   |          |         |
| 1000万 | 5万   |          |         |
| 1000万 | 10万  |          |         |

## 思路三：MirrorMaker 2.0 + 思路二

[KIP-382: MirrorMaker 2.0 - Apache Kafka - Apache Software Foundation](https://cwiki.apache.org/confluence/display/KAFKA/KIP-382%3A+MirrorMaker+2.0)

MirrorMaker不是RPO=0的，会丢一部分数据。对丢失的这部分数据，其顺序是保存在DB里面的。消费者采用无限缓存方案，恢复出完整顺序。

- 消费者需要从哪里开始消费呢？分区P从主机房同步到备机房为P1，P-P1为丢失的数据。从P1里面找到生产者A、B的最后一条数据为n，那么A、B需要从n+1的位置开始往P1写消息。
- 如果从生产者入手，那么A、B需要利用DB里面的顺序进行协调，按照DB里面的顺序，逐个写消息。这样就能保证P1-P这一段消息的顺序也与主机房一致。由于数据量小，即使很慢也没关系。
- 如果从消费者入手，A、B无需协调顺序，只要保证P1-P这段数据都写进去即可。消费者C消费时，从断点P1开始消费，采用无限缓存方案，将顺序纠正过来，确保发到下游的顺序与主机房一致。




